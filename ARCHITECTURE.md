# P2P聊天系统架构说明

本文档详细说明P2P聊天系统的架构设计、技术选型和实现细节，帮助开发者理解系统结构和扩展功能。

## 系统架构

P2P聊天系统采用纯前端架构，基于WebRTC技术实现点对点通信，不依赖中心服务器进行消息中转。系统架构如下：

```
+-------------------+                      +-------------------+
|                   |                      |                   |
|    用户 A 浏览器    |                      |    用户 B 浏览器    |
|                   |                      |                   |
+-------------------+                      +-------------------+
        |                                          |
        |                                          |
        v                                          v
+-------------------+                      +-------------------+
|                   |                      |                   |
|   WebRTC 数据通道   | <-------------------> |   WebRTC 数据通道   |
|   (加密消息传输)    |                      |   (加密消息传输)    |
|                   |                      |                   |
+-------------------+                      +-------------------+
        ^                                          ^
        |                                          |
        |                                          |
        v                                          v
+-------------------+                      +-------------------+
|                   |                      |                   |
|   PeerJS 客户端    |                      |   PeerJS 客户端    |
|                   |                      |                   |
+-------------------+                      +-------------------+
        ^                                          ^
        |                                          |
        |                                          |
        +----------------+            +------------+
                         |            |
                         v            v
                  +-------------------+
                  |                   |
                  |  PeerJS 信令服务器  |
                  | (仅用于连接建立)    |
                  |                   |
                  +-------------------+
                         |
                         |
                         v
                  +-------------------+
                  |                   |
                  |   STUN 服务器     |
                  | (用于NAT穿透)      |
                  |                   |
                  +-------------------+
```

### 关键组件

1. **React前端应用**：提供用户界面和交互逻辑
2. **PeerJS客户端**：封装WebRTC API，简化连接建立过程
3. **WebRTC数据通道**：提供点对点通信能力
4. **加密模块**：实现ECDH密钥协商和AES-256加密
5. **PeerJS信令服务器**：仅用于连接建立阶段的信令交换
6. **STUN服务器**：辅助NAT穿透，帮助确定公网IP和端口

## 技术选型详解

### 前端框架：React

选择React作为前端框架的原因：
- 组件化开发模式，便于UI复用和状态管理
- 虚拟DOM提高渲染性能
- 丰富的生态系统和社区支持
- 与WebRTC和加密库良好的兼容性

### P2P通信：WebRTC + PeerJS

选择WebRTC的原因：
- 浏览器原生支持的点对点通信技术
- 支持数据通道、音频和视频传输
- 内置NAT穿透机制
- 安全的通信通道

选择PeerJS的原因：
- 简化WebRTC的复杂API
- 提供免费的信令服务器
- 易于集成和使用
- 减少开发时间和复杂度

### 加密技术：ECDH + AES-256

选择ECDH的原因：
- 高效的密钥协商算法
- 适合前端JavaScript环境
- 提供前向安全性
- 密钥长度短但安全性高

选择AES-256的原因：
- 广泛认可的对称加密标准
- 高安全性和良好性能平衡
- 浏览器环境下实现高效
- 支持CBC模式和IV增强安全性

### 样式处理：Styled Components

选择Styled Components的原因：
- 组件级CSS隔离
- 动态样式生成能力
- 与React组件模型完美契合
- 提高代码可维护性

## 数据流

### 连接建立流程

1. 用户A输入自己的ID和用户B的ID
2. 用户A通过PeerJS信令服务器发送连接请求
3. 用户B接收连接请求并接受
4. 双方交换ICE候选，建立WebRTC连接
5. 连接建立后，执行ECDH密钥协商
6. 生成共享密钥用于后续消息加密

```
用户A                                      用户B
  |                                         |
  |--- 1. 发起连接请求 --->                   |
  |                    |                    |
  |                    |--- 2. 转发请求 ---->|
  |                                         |
  |<---- 3. 接受连接 -------------------------|
  |                                         |
  |<==== 4. ICE候选交换 =====================>|
  |                                         |
  |<==== 5. WebRTC连接建立 =================>|
  |                                         |
  |---- 6. 发送公钥 ------------------------->|
  |                                         |
  |<---- 7. 发送公钥 -------------------------|
  |                                         |
  |---- 8. 加密通信开始 --------------------->|
```

### 消息发送流程

1. 用户A输入消息文本
2. 创建消息对象（包含文本、发送者ID和时间戳）
3. 使用共享密钥和AES-256加密消息
4. 通过WebRTC数据通道发送加密消息
5. 用户B接收加密消息
6. 使用共享密钥解密消息
7. 显示解密后的消息内容

## 模块详解

### 服务模块

#### peerService.js

负责WebRTC连接管理，包括：
- 初始化PeerJS客户端
- 建立和管理P2P连接
- 处理连接事件（连接、断开、错误等）
- 配置STUN服务器

#### encryptionService.js

负责加密功能，包括：
- ECDH密钥对生成
- 共享密钥派生
- AES-256加密和解密
- 密钥交换消息处理

#### messageService.js

负责消息处理，包括：
- 创建消息对象
- 序列化和反序列化消息
- 消息格式验证

### 组件模块

#### ConnectionScreen.js

负责连接界面，包括：
- 用户ID输入和验证
- 目标ID输入和验证
- 连接状态显示
- 连接建立和错误处理
- 密钥协商初始化

#### ChatScreen.js

负责聊天界面，包括：
- 消息显示和排版
- 消息输入和发送
- 加密消息处理
- 连接状态监控

#### ErrorScreen.js

负责错误处理，包括：
- 显示错误信息
- 提供重试选项
- 错误原因分析

## 安全考量

### 密钥管理

- 私钥仅存储在用户浏览器的sessionStorage中
- 会话结束后密钥自动销毁
- 不将密钥传输到任何服务器

### 加密实现

- 使用CBC模式的AES-256加密
- 每条消息使用随机初始化向量(IV)
- IV与密文一起传输以确保解密

### 潜在风险

- 中间人攻击：依赖WebRTC的安全通道和PeerJS信令服务器的可信度
- 浏览器安全：依赖浏览器的安全实现和隔离机制
- ID碰撞：当前实现不处理ID冲突，生产环境应增加验证

## 扩展指南

### 添加视频/语音通话

1. 扩展peerService.js以支持MediaStream
2. 添加媒体协商和控制组件
3. 实现媒体流的获取和显示
4. 添加音视频控制UI

```javascript
// 获取媒体流示例
navigator.mediaDevices.getUserMedia({ video: true, audio: true })
  .then(stream => {
    // 将流添加到peer连接
    const call = peer.call(targetId, stream);
    
    // 处理接收到的流
    call.on('stream', remoteStream => {
      // 显示远程视频
      remoteVideo.srcObject = remoteStream;
    });
  });
```

### 实现群聊功能

1. 实现Mesh网络连接管理
2. 扩展消息广播机制
3. 添加群组管理UI
4. 优化多连接性能

### 添加文件传输

1. 实现文件分块和重组
2. 扩展加密服务以支持大文件
3. 添加文件传输进度UI
4. 实现文件类型检测和预览

## 性能优化

- 使用WebWorker处理加密操作，避免阻塞主线程
- 实现消息分页加载，优化长时间聊天的性能
- 使用IndexedDB缓存消息，支持离线查看
- 优化重连机制，提高网络波动时的稳定性

## 部署注意事项

- 确保部署环境支持HTTPS（WebRTC要求）
- 考虑使用专用STUN/TURN服务器提高NAT穿透成功率
- 对于高流量应用，考虑自建PeerJS信令服务器
- 监控WebRTC连接质量，提供网络状况反馈
